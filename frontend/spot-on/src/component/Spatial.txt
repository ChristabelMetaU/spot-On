what to do:

Users have location based spot loading,
Implement an algorithm from scratch to achieve this.
(display or focus on spots near users location).
Radius limited Results(avoid loading spots in a far distance to optimize performance)
Users have smart map panning.
Efficient Nearby spot lookup
Efficient display of clustered spots into one marker with total number of spots in raduis.


What i want
find parking spota within 100 m radius of the user


plan:
Store locations with latitude and longitude.
Write a custom function that calculates distance using the Haversine formula (or similar).
Filter manually by radius.
Optimize with indexing or bounding boxes.


The plan is
The backend (Node.js) receives a user's location + radius, and:
Calls the database.
Gets results (parking spots nearby)

we can make a custome function similar to st within but better and fits our project better.
for spatial queries, we can use a spatial index like R-tree to improve the performance of the query.
additional information:
what my custom function wull liik like:
AI Overview
In spatial databases and Geographic Information Systems (GIS), ST_Within is a spatial relationship function that checks if one geometry is entirely contained within another. It determines if geometry A is completely inside geometry B.
What it does:
Spatial Containment: ST_Within(A, B) returns TRUE (or 1) if geometry A's interior and boundary have no points outside of geometry B's exterior.
Converse of ST_Contains: ST_Within(A, B) is the topological opposite of ST_Contains(B, A). If A is within B, then B contains A.
Topological Equality: If ST_Within(A, B) and ST_Within(B, A) are both true, then A and B are considered spatially equal.
How it works under the hood (general principles, specific implementation details vary based on the GIS software/database):
Bounding Box Comparison: ST_Within typically starts with a fast bounding box comparison. If A's bounding box is not completely within B's bounding box, the function can immediately return FALSE without performing more complex calculations.
Spatial Indexes: It leverages spatial indexes (like R-Trees) if available. This significantly speeds up the initial bounding box check and helps narrow down the search space. R-Trees are specialized tree data structures designed for spatial access methods, indexing multi-dimensional information like geographical coordinates, rectangles, or polygons. They efficiently organize data by hierarchically partitioning space into bounding boxes.
Geometry Relationship Test: If the bounding box check suggests potential containment, more detailed geometry comparisons are performed to determine the exact spatial relationship. This might involve algorithms that examine the intersection of interiors and boundaries of the geometries.
Point in Polygon (PIP) short-circuit: Some implementations like PostGIS have enhancements that optimize for specific scenarios, such as quickly checking if a point is within a polygon.
Important Notes:
Same Coordinate System: Both geometries must be in the same spatial reference system (SRS) or coordinate projection for ST_Within to work correctly.
Boundary Subtlety: A key detail is that the boundary of a geometry is not considered to be "within" the geometry. So, a point or line segment strictly on the boundary would not return TRUE for ST_Within.
Avoid Invalid Geometries: ST_Within should not be used with invalid geometries, as it can lead to unexpected results.
In essence, ST_Within determines if one geometric shape is entirely inside another, utilizing efficient spatial indexing and comparison algorithms to perform this check.





Task 2:
summarizing the parking spots in a 100m radius of the user before zooming in.
solution spatial clustering
We can use k-means clustering
3. Frontend Clustering Logic
build from scratch using like k-means clustering K-Means clustering can be a valuable technique for optimizing spatial queries in a parking spot app by organizing and grouping parking spots based on their proximity and potentially other relevant factors.
Here's how it can be used:
Partitioning Parking Data:
Instead of storing all available parking spots in a single dataset, K-Means can be used to cluster them based on their geographic coordinates (latitude and longitude).
Each cluster would represent a distinct geographical area with a high concentration of parking spots.
Indexing and Querying Efficiency:
Once the data is clustered, you can create spatial indexes for each cluster.
When a user searches for parking spots within a specific area, the app can first identify the relevant clusters based on the user's location or search criteria.
This significantly reduces the search space, as the app only needs to query the data within the relevant clusters instead of searching through the entire dataset.
Improved Scalability:
K-Means is a scalable algorithm, making it suitable for handling large volumes of spatial data, which is essential for a parking spot app that grows over time.
By partitioning the data, the workload can be distributed across multiple servers or resources, improving query performance and scalability.
Additional Optimization with Non-Spatial Data:
K-Means can also incorporate non-spatial attributes into the clustering process.
For example, you could include factors like parking spot availability, cost, amenities, or restrictions to create more specific clusters.
This allows for more refined searches and personalized results for users.
In summary, by using K-Means clustering to partition parking data into spatial clusters and then indexing those clusters, your parking spot app can achieve:
Faster query response times: By reducing the search space to only relevant clusters.
Improved scalability: By distributing the data and workload across multiple resources.
More relevant search results: By considering proximity and other relevant factors in the clustering process.
This approach allows your app to efficiently manage and query large datasets of parking spots, providing a better user experience.
Use supercluster to group those points into clusters dynamically.

It handles zoom levels, merges nearby points, and outputs cluster coordinates + counts.
